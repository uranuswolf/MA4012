#pragma config(Sensor, dgtl2,  RIGHT_ENCODER,  sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  LEFT_ENCODER,   sensorQuadEncoder)
#pragma config(Motor,  port3,  motorLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,  motorRight,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//

// PID constants
float kP = 0.5;
float kI = 0.01;
float kD = 0.1;

// Wheel and encoder specifications
float wheelDiameter = 0.06985; // in meters
float wheelCircumference = wheelDiameter * 3.14159; // meters
int ticksPerRevolution = 90; // VEX encoder ticks per shaft revolution
float distancePerTick = wheelCircumference / ticksPerRevolution; // meters per tick

// Convert desired distance (meters) to encoder ticks
int distanceToTicks(float distance) {
    return distance / distancePerTick;
}

// PID-based movement function
void moveForwardPID(float distance) {
    int targetTicks = distanceToTicks(distance);

    // Reset encoders
    SensorValue[LEFT_ENCODER] = 0;
    SensorValue[RIGHT_ENCODER] = 0;

    int leftError, rightError;
    int leftIntegral = 0, rightIntegral = 0;
    int leftDerivative, rightDerivative;
    int lastLeftError = 0, lastRightError = 0;
    int leftPower, rightPower;

    while (true) {
        int leftPos = SensorValue[LEFT_ENCODER];
        int rightPos = SensorValue[RIGHT_ENCODER];

        // Compute separate errors
        leftError = targetTicks - leftPos;
        rightError = targetTicks - rightPos;

        // Stop condition: If both wheels have reached the target
        if (abs(leftError) < 5 && abs(rightError) < 5) {
            break;
        }

        // Compute integral
        leftIntegral += leftError;
        rightIntegral += rightError;

        // Compute derivative
        leftDerivative = leftError - lastLeftError;
        rightDerivative = rightError - lastRightError;

        lastLeftError = leftError;
        lastRightError = rightError;

        // Compute PID outputs
        int leftPID = (kP * leftError) + (kI * leftIntegral) + (kD * leftDerivative);
        int rightPID = (kP * rightError) + (kI * rightIntegral) + (kD * rightDerivative);

        // Apply PID output to motor power
        leftPower = 50 + leftPID;
        rightPower = 50 + rightPID;

        // Ensure motor power stays within limits (-127 to 127)
        if (leftPower > 127) leftPower = 127;
        if (rightPower > 127) rightPower = 127;
        if (leftPower < -127) leftPower = -127;
        if (rightPower < -127) rightPower = -127;

        // Set motor power
        motor[motorLeft] = leftPower;
        motor[motorRight] = -rightPower; //because of mirror image

        wait1Msec(20); // Short delay for stability
    }

    // Stop motors
    motor[motorLeft] = 0;
    motor[motorRight] = 0;
}

task main() {
    moveForwardPID(1.5); // Move forward 1.5 meters
}
