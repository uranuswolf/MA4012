#pragma config(Sensor, dgtl2,  RIGHT_ENCODER,  sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  LEFT_ENCODER,   sensorQuadEncoder)
#pragma config(Motor,  port3,  motorLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,  motorRight,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//

#define max_Ticks_per_sec 1450
#define LEFT_MOTOR motor[motorLeft]
#define RIGHT_MOTOR motor[motorRight]

// PID variables
int error, prevError = 0;
int integral = 0;
int derivative = 0;

void resetEncoders() {
    SensorValue[LEFT_ENCODER] = 0;
    SensorValue[RIGHT_ENCODER] = 0;
}

int getLeftEncoderSpeed() {
    int initialTicks = SensorValue[LEFT_ENCODER];
    wait1Msec(10);
    int finalTicks = SensorValue[LEFT_ENCODER];
    int currentTicks_per_sec = (finalTicks - initialTicks) * 100;
    return (currentTicks_per_sec * 127) / max_Ticks_per_sec;
}

int getRightEncoderSpeed() {
    int initialTicks = SensorValue[RIGHT_ENCODER];
    wait1Msec(10);
    int finalTicks = SensorValue[RIGHT_ENCODER];
    int currentTicks_per_sec = (finalTicks - initialTicks) * 100;
    return (currentTicks_per_sec * 127) / max_Ticks_per_sec;
}

int computePID(int desiredSpeed, int actualSpeed) {
    error = desiredSpeed - actualSpeed;
    integral += error;
    derivative = error - prevError;
    prevError = error;
    
    int output = (0.5 * error) + (0.01 * integral) + (0.1 * derivative);
    if (output > 127) output = 127;
    if (output < -127) output = -127;
    
    return output;
}

void resetPID() {
    error = 0;
    prevError = 0;
    integral = 0;
    derivative = 0;
}

void stopMotors() {
    int leftTicks = SensorValue[LEFT_ENCODER];
    int rightTicks = SensorValue[RIGHT_ENCODER];

    // Encoder correction before stopping
    if (leftTicks > rightTicks) {
        RIGHT_MOTOR = 10; // Boost right motor slightly
        wait1Msec(100);
    } else if (rightTicks > leftTicks) {
        LEFT_MOTOR = 10; // Boost left motor slightly
        wait1Msec(100);
    }

    // Apply brief reverse power to balance braking
    LEFT_MOTOR = -10;
    RIGHT_MOTOR = -10;
    wait1Msec(100);

    LEFT_MOTOR = 0;
    RIGHT_MOTOR = 0;
}

void moveForward(int speed, int duration) {
    resetPID();
    resetEncoders();
    int startTime = nSysTime;
    
    int leftOffset = 42;  // Adjust as needed for straight motion
    int rightOffset = 0;

    while (nSysTime - startTime < duration - 500) { // Normal motion
        int leftPower = computePID(speed, getLeftEncoderSpeed()) + leftOffset;
        int rightPower = -computePID(speed, getRightEncoderSpeed()) + rightOffset;

        LEFT_MOTOR = leftPower;
        RIGHT_MOTOR = rightPower;
    }

    // Gradual slow down in the last 500ms
    for (int i = 0; i <= 10; i++) {
        LEFT_MOTOR = (LEFT_MOTOR * (10 - i)) / 10;
        RIGHT_MOTOR = (RIGHT_MOTOR * (10 - i)) / 10;
        wait1Msec(50);
    }

    stopMotors();
}

//void moveBackward(int speed, int duration) {
    //resetPID();
    //resetEncoders();
    //int startTime = nSysTime;
    //while (nSysTime - startTime < duration) {
        //LEFT_MOTOR = -computePID(speed, getLeftEncoderSpeed());
        //RIGHT_MOTOR = computePID(speed, getRightEncoderSpeed());
    //}
    //stopMotors();
//}

//void turnLeft(int speed, int duration) {
    //resetPID();
   // resetEncoders();
    //int startTime = nSysTime;
    //while (nSysTime - startTime < duration) {
        //LEFT_MOTOR = -computePID(speed, getLeftEncoderSpeed());
        //RIGHT_MOTOR = -computePID(speed, getRightEncoderSpeed());
    //}
    //stopMotors();
//}

//void turnRight(int speed, int duration) {
    //resetPID();
    //resetEncoders();
    //int startTime = nSysTime;
    //while (nSysTime - startTime < duration) {
        //LEFT_MOTOR = computePID(speed, getLeftEncoderSpeed());
        //RIGHT_MOTOR = computePID(speed, getRightEncoderSpeed());
    //}
    //stopMotors();
//}

task main() {
    moveForward(-127, 2000); // Move forward at speed 127 for 2 seconds
    //wait1Msec(500); // Small delay
    //turnLeft(60, 1000); // Turn left for 1 second
    //wait1Msec(500);
    //moveBackward(80, 2000); // Move backward at speed 80 for 2 seconds
    //wait1Msec(500);
    //turnRight(60, 1000); // Turn right for 1 second
    stopMotors();
}
