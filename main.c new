#pragma config(Sensor, dgtl2,  RIGHT_ENCODER,  sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  LEFT_ENCODER,   sensorQuadEncoder)
#pragma config(Motor,  port3,  motorLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,  motorRight,     tmotorVex393_MC29, openLoop)

// Base motor power for movement
int basePower = 50;

// Wheel and encoder specs
float wheelDiameter = 0.06985; // meters
float wheelCircumference = wheelDiameter * 3.14159; // meters
int ticksPerRevolution = 90; // encoder ticks per revolution
float distancePerTick = wheelCircumference / ticksPerRevolution; // meters per tick
float wheelBase = 0.188; // distance between wheels (meters)

// Convert distance in meters to encoder ticks
int distanceToTicks(float distance) {
    return distance / distancePerTick;
}

// Move forward or backward by a distance (in meters)
void moveDistance(float distance, bool backward = false) {
    int targetTicks = distanceToTicks(distance);
    SensorValue[LEFT_ENCODER] = 0;
    SensorValue[RIGHT_ENCODER] = 0;

    if (backward) {
        // Reverse direction
        motor[motorLeft] = basePower;
        motor[motorRight] = -basePower;
    } else {
        // Forward direction
        motor[motorLeft] = -basePower;
        motor[motorRight] = basePower;
    }

    while (abs(SensorValue[LEFT_ENCODER]) < targetTicks &&
           abs(SensorValue[RIGHT_ENCODER]) < targetTicks) {
        wait1Msec(10);
    }

    // Stop motors
    motor[motorLeft] = 0;
    motor[motorRight] = 0;
}

// Turn left or right in place by a specific number of degrees
void turnDegrees(float degrees, bool right = false) {
    // Calculate arc length for one wheel (robot turns in place)
    float arcLength = (degrees / 180.0) * 3.14159 * (wheelBase / 2.0);
    int targetTicks = distanceToTicks(arcLength);
    SensorValue[LEFT_ENCODER] = 0;
    SensorValue[RIGHT_ENCODER] = 0;

    if (right) {
        // Turn right: left motor forward, right motor backward
        motor[motorLeft] = -basePower;
        motor[motorRight] = -basePower;
    } else {
        // Turn left: left motor backward, right motor forward
        motor[motorLeft] = basePower;
        motor[motorRight] = basePower;
    }

    while (abs(SensorValue[LEFT_ENCODER]) < targetTicks &&
           abs(SensorValue[RIGHT_ENCODER]) < targetTicks) {
        wait1Msec(10);
    }

    // Stop motors
    motor[motorLeft] = 0;
    motor[motorRight] = 0;
}

// Main routine
task main() {
    moveDistance(1.0);       // Move forward 1 meter
    wait1Msec(1000);
    moveDistance(1.0, true); // Move backward 1 meter
    wait1Msec(1000);
    turnDegrees(90);         // Turn left 90 degrees
    wait1Msec(1000);
    turnDegrees(90, true);   // Turn right 90 degrees
}

