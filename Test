#pragma config(Sensor, dgtl2, RIGHT_ENCODER, sensorQuadEncoder)
#pragma config(Sensor, dgtl4, LEFT_ENCODER, sensorQuadEncoder)
#pragma config(Motor, port3, motorLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor, port4, motorRight, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//

#define LEFT_MOTOR motor[motorLeft]
#define RIGHT_MOTOR motor[motorRight]
#define MAX_TICKS_PER_SEC 1450

// PID constants
float kP = 0.5;
float kI = 0.0;
float kD = 0.1;

// PID state
int error, prevError = 0;
int integral = 0;
int derivative = 0;

// Motor offsets
int leftMotorOffset = 0;
int rightMotorOffset = 0;

// ----- Utility Functions -----

void resetEncoders() {
    SensorValue[LEFT_ENCODER] = 0;
    SensorValue[RIGHT_ENCODER] = 0;
}

void resetPID() {
    error = 0;
    prevError = 0;
    integral = 0;
    derivative = 0;
}

void setMotorPower(int leftPower, int rightPower) {
    LEFT_MOTOR = leftPower + leftMotorOffset;
    RIGHT_MOTOR = rightPower + rightMotorOffset;
}

// Get encoder speed (change in ticks over time)
int getEncoderSpeed(tSensors encoder) {
    int prev = SensorValue[encoder];
    wait1Msec(25);
    return abs(SensorValue[encoder] - prev) * 40; // ticks per second
}

// PID controller to reach a target speed
int computePID(int targetSpeed, int currentSpeed) {
    error = targetSpeed - currentSpeed;
    integral += error;
    derivative = error - prevError;
    prevError = error;

    return (kP * error) + (kI * integral) + (kD * derivative);
}

// ----- Motor Behavior -----

void stopMotors() {
    setMotorPower(0, 0);
    wait1Msec(100);
}

void moveForward(int speed, int duration) {
    resetEncoders();
    resetPID();

    int startTime = nSysTime;

    while (nSysTime - startTime < duration) {
        int leftSpeed = getEncoderSpeed(LEFT_ENCODER);
        int rightSpeed = getEncoderSpeed(RIGHT_ENCODER);

        int leftPower = computePID(speed, leftSpeed);
        int rightPower = computePID(speed, rightSpeed);

        setMotorPower(leftPower, rightPower);
    }

    stopMotors();
}

void moveBackward(int speed, int duration) {
    resetEncoders();
    resetPID();

    int startTime = nSysTime;

    while (nSysTime - startTime < duration) {
        int leftSpeed = getEncoderSpeed(LEFT_ENCODER);
        int rightSpeed = getEncoderSpeed(RIGHT_ENCODER);

        int leftPower = -computePID(speed, leftSpeed);
        int rightPower = -computePID(speed, rightSpeed);

        setMotorPower(leftPower, rightPower);
    }

    stopMotors();
}

void turnLeft(int speed, int duration) {
    resetEncoders();
    resetPID();

    int startTime = nSysTime;

    while (nSysTime - startTime < duration) {
        int leftSpeed = getEncoderSpeed(LEFT_ENCODER);
        int rightSpeed = getEncoderSpeed(RIGHT_ENCODER);

        int leftPower = -computePID(speed, leftSpeed);
        int rightPower = computePID(speed, rightSpeed);

        setMotorPower(leftPower, rightPower);
    }

    stopMotors();
}

void turnRight(int speed, int duration) {
    resetEncoders();
    resetPID();

    int startTime = nSysTime;

    while (nSysTime - startTime < duration) {
        int leftSpeed = getEncoderSpeed(LEFT_ENCODER);
        int rightSpeed = getEncoderSpeed(RIGHT_ENCODER);

        int leftPower = computePID(speed, leftSpeed);
        int rightPower = -computePID(speed, rightSpeed);

        setMotorPower(leftPower, rightPower);
    }

    stopMotors();
}

// ----- Main -----

task main() {
    moveForward(200, 2000); // Move forward for 2 seconds at speed ~200 ticks/sec
    wait1Msec(500);
    turnLeft(150, 1000);    // Turn left for 1 second
    wait1Msec(500);
    moveBackward(200, 2000); // Move backward for 2 seconds
    wait1Msec(500);
    turnRight(150, 1000);   // Turn right for 1 second
}
